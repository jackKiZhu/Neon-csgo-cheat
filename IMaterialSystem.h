#include "KeyValues.h"
#include "CMaterialReferences.h"

class KeyValues;
typedef unsigned short MaterialHandle_t;
class CMatRenderContext {
private:
	BYTE	__unknownBYTEs[12];
	void**	__pUnkTypeMaterial;
public:
	IClientRenderable* m_pRenderEntity;
};




enum RenderTargetSizeMode_t
{
	RT_SIZE_NO_CHANGE = 0,			// Only allowed for render targets that don't want a depth buffer
	// (because if they have a depth buffer, the render target must be less than or equal to the size of the framebuffer).
	RT_SIZE_DEFAULT = 1,				// Don't play with the specified width and height other than making sure it fits in the framebuffer.
	RT_SIZE_PICMIP = 2,				// Apply picmip to the render target's width and height.
	RT_SIZE_HDR = 3,					// frame_buffer_width / 4
	RT_SIZE_FULL_FRAME_BUFFER = 4,	// Same size as frame buffer, or next lower power of 2 if we can't do that.
	RT_SIZE_OFFSCREEN = 5,			// Target of specified size, don't mess with dimensions
	RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6, // Same size as the frame buffer, rounded up if necessary for systems that can't do non-power of two textures.
	RT_SIZE_REPLAY_SCREENSHOT = 7,	// Rounded down to power of 2, essentially...
	RT_SIZE_LITERAL = 8				// Use the size passed in. Don't clamp it to the frame buffer size. Really.
};

enum MaterialRenderTargetDepth_t
{
	MATERIAL_RT_DEPTH_SHARED = 0x0,
	MATERIAL_RT_DEPTH_SEPARATE = 0x1,
	MATERIAL_RT_DEPTH_NONE = 0x2,
	MATERIAL_RT_DEPTH_ONLY = 0x3,
};
enum CompiledVtfFlags
{
	// flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_SRGB = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	// newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY = 0x00040000,

	TEXTUREFLAGS_STAGING_MEMORY = 0x00080000,
	TEXTUREFLAGS_IMMEDIATE_CLEANUP = 0x00100000,
	TEXTUREFLAGS_IGNORE_PICMIP = 0x00200000,
	TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,

	TEXTUREFLAGS_CLAMPU = 0x02000000,

	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,					// Useable as a vertex texture

	TEXTUREFLAGS_SSBUMP = 0x08000000,

	TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,

	// Clamp to border color on all texture coordinates
	TEXTUREFLAGS_BORDER = 0x20000000,

	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
};

#define CREATERENDERTARGETFLAGS_HDR				0x00000001

class IMaterialSystem
{
public:
	char pad[0x2C68];
	IMaterial* CreateMaterial(const char *pMaterialName, KeyValues *pVMTKeyValues)
	{
		typedef IMaterial*(__thiscall* CreateMaterialFn)(void*, const char *pMaterialName, KeyValues *pVMTKeyValues);
		return CallVFunc<CreateMaterialFn>(this, 83)(this, pMaterialName, pVMTKeyValues);
	}

	IMaterial* FindMaterial(const char* pMaterialName, const char* pTextureGroupName = "Model textures", bool complain = true, const char* pComplainPrefix = NULL)
	{
		typedef IMaterial* (__thiscall* FindMaterialFn)(void*, const char*, const char*, bool, const char*);
		return CallVFunc<FindMaterialFn>(this, 84)(this, pMaterialName, pTextureGroupName, complain, pComplainPrefix);
	}

	MaterialHandle_t FirstMaterial()
	{
		typedef MaterialHandle_t(__thiscall* FirstMaterialFn)(void*);
		return CallVFunc<FirstMaterialFn>(this, 86)(this);
	}

	MaterialHandle_t NextMaterial(MaterialHandle_t h)
	{
		typedef MaterialHandle_t(__thiscall* NextMaterialFn)(void*, MaterialHandle_t);
		return CallVFunc<NextMaterialFn>(this, 87)(this, h);
	}

	MaterialHandle_t InvalidMaterial()
	{
		typedef MaterialHandle_t(__thiscall* InvalidMaterialFn)(void*);
		return CallVFunc<InvalidMaterialFn>(this, 88)(this);
	}

	IMaterial* GetMaterial(MaterialHandle_t h)
	{
		typedef IMaterial*(__thiscall* GetMaterialFn)(void*, MaterialHandle_t);
		return CallVFunc<GetMaterialFn>(this, 89)(this, h);
	}

	IMatRenderContext* GetRenderContext()
	{
		typedef IMatRenderContext* (__thiscall* GetRenderContextFn)(PVOID);
		return CallVFunc<GetRenderContextFn>(this, 115)(this);
	}

	IClientEntity* GetRenderingEntity()
	{
		CMatRenderContext* context = (CMatRenderContext*)GetRenderContext();
		if (!context)
			return NULL;

		DWORD dwEntity = (DWORD)context->m_pRenderEntity;
		if (!dwEntity)
			return NULL;

		//context->Release();
		return (IClientEntity*)(dwEntity - 4);
	}

	ImageFormat GetBackBufferFormat()
	{
		typedef ImageFormat(__thiscall* CreateMaterialFn)(void*);
		return CallVFunc<CreateMaterialFn>(this, 36)(this);
	}

	//DVMethod(ImageFormat(), GetBackBufferFormat, StaticVIndex<36>);

	void BeginRenderTargetAllocation()
	{
		typedef void(__thiscall* CreateMaterialFn)(void*);
		return CallVFunc<CreateMaterialFn>(this, 94)(this);
	}

	//DVMethod(void(), BeginRenderTargetAllocation, StaticVIndex<94>);

	void EndRenderTargetAllocation()
	{
		typedef void(__thiscall* CreateMaterialFn)(void*);
		return CallVFunc<CreateMaterialFn>(this, 95)(this);
	}

	//	DVMethod(void(), EndRenderTargetAllocation, StaticVIndex<95>);

	ITexture* CreateNamedRenderTargetTextureEx(const char* name, int w, int h, RenderTargetSizeMode_t sizeMode,
		ImageFormat format, MaterialRenderTargetDepth_t depth,
		unsigned int textureFlags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, unsigned int renderTargetFlags = 0)
	{
		typedef ITexture* (__thiscall* CreateMaterialFn)(void*, const char* , int , int , RenderTargetSizeMode_t ,
			ImageFormat , MaterialRenderTargetDepth_t ,
			unsigned int, unsigned int);
		return CallVFunc<CreateMaterialFn>(this, 97)(this, name,  w,  h, sizeMode,
			 format, depth, textureFlags, renderTargetFlags);
	}

	//bool m_bGameStarted()
	//{
	//	static auto a = NetVarManager::GetOffset("DT_BasePlayer", "m_iHealth");
	//	return *(bool*)((DWORD)this + a);
	//}

	//DVar(bool, m_bGameStarted, PatternOffset<modules::materialsystem, patterns::CMaterialSystem_m_bGameStarted>);

	bool& m_bGameStarted();

	void forceBeginRenderTargetAllocation() {
		//bool oldState = m_bGameStarted;
		//m_bGameStarted = false;         // Fooling the game that loading is not finished yet
		BeginRenderTargetAllocation();
		//m_bGameStarted = oldState;
	}

	void forceEndRenderTargetAllocation() {
		//bool oldState = m_bGameStarted;
		//m_bGameStarted = false;
		EndRenderTargetAllocation();
		//m_bGameStarted = oldState;
	}

	ITexture* createFullFrameRenderTarget(const char* name);

	//DVMethod(ITexture* (
	//	
	//	), CreateNamedRenderTargetTextureEx, StaticVIndex<97>);

	//DVar(bool, m_bGameStarted, PatternOffset<modules::materialsystem, patterns::CMaterialSystem_m_bGameStarted>);

};

IMaterialSystem* g_pMatSystem;